<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <!-- * NUEVO: Viewport para móviles, deshabilita zoom de usuario --><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Fortaleza de Añicos</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Press+Start+2P', monospace;
            overflow: hidden;
            background-color: #000;
            /* Previene el "bounce" en iOS */
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        canvas {
            background-color: #1a1a1a;
            border-bottom: 5px solid #444;
            /* * MODIFICADO: Canvas responsivo */
            width: 100%;
            height: auto;
            max-width: 1024px; /* Mantiene la proporción en pantallas grandes */
            image-rendering: auto; /* Gráficos suaves */
        }
        
        .status-message {
            display: none;
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFFF00;
            font-size: 1.5rem;
            text-shadow: 2px 2px #000;
            z-index: 100;
        }

        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            padding: 1rem;
            text-align: center;
        }

        /* * NUEVO: Contenedor para los controles táctiles */
        #touch-controls {
            position: absolute;
            /* * MODIFICADO: Subido 1.5rem (24px) del borde inferior */
            bottom: 1.5rem;
            left: 0;
            right: 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            /* * MODIFICADO: Padding ajustado */
            padding: 0.5rem 1rem;
            /* Ocultar en escritorio (md y superior) */
            @media (min-width: 768px) {
                display: none;
            }
        }

        /* * NUEVO: Estilo de los botones táctiles */
        .touch-btn {
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            /* * MODIFICADO: Tamaño de fuente más pequeño */
            font-size: 1.25rem;
            border-radius: 50%; /* Círculos */
            /* * MODIFICADO: Botones más pequeños */
            width: 55px;
            height: 55px;
            display: flex;
            justify-content: center;
            align-items: center;
            /* * MODIFICADO: Margen entre botones reducido */
            margin: 0 0.25rem;
            user-select: none; /* Evita la selección de texto */
            -webkit-tap-highlight-color: transparent; /* Evita el destello en el toque */
        }
        
        .touch-btn:active {
            background-color: rgba(255, 255, 255, 0.4);
        }
    </style>
</head>
<body class="bg-black text-white overflow-hidden">

    <div id="game-container" class="w-screen h-screen flex flex-col items-center justify-center">

        <div id="ui-bar" class="w-full max-w-4xl p-2 md:p-4 flex flex-wrap justify-between items-center text-base md:text-2xl gap-2 md:gap-4">
            <div class="flex gap-4">
                <div>
                    <span>PUNTOS: </span>
                    <span id="score" class="text-yellow-400">0</span>
                </div>
                <div>
                    <span>MUNICIÓN: </span>
                    <span id="ammo" class="text-red-500">8</span>
                </div>
                <!-- * NUEVO: Contador de Granadas -->
                <div>
                    <span>GRANADAS: </span>
                    <span id="grenades" class="text-blue-400">0</span>
                </div>
            </div>
             <!-- * NUEVO: Botón de Comprar Granada -->
            <div>
                <button id="buy-grenade" class="text-sm md:text-lg bg-blue-600 px-2 py-1 rounded disabled:opacity-50 disabled:cursor-not-allowed" disabled>COMPRAR (2000)</button>
            </div>
        </div>

        <canvas id="game-canvas" width="1024" height="576"></canvas>

        <div id="reload-message" class="status-message">RECARGANDO...</div>

        <div id="start-screen" class="screen-overlay">
            <h1 class="text-3xl md:text-6xl text-red-600 mb-8">FORTALEZA DE AÑICOS</h1>
            <p class="text-sm md:text-xl mb-2">Usa [A] [D] o [Flechas] para moverte.</p>
            <p class="text-sm md:text-xl mb-2">Usa [S] o [Flecha Abajo] para agacharte.</p>
            <p class="text-sm md:text-xl mb-2">Usa [CTRL] para saltar.</p>
            <p class="text-sm md:text-xl mb-2">Usa [ESPACIO] para disparar.</p>
            <p class="text-sm md:text-xl mb-2">Usa [R] para recargar.</p>
            <!-- * NUEVO: Instrucción de Granada -->
            <p class="text-sm md:text-xl mb-6">Usa [G] para lanzar granada.</p>
            <button id="start-button" class="bg-yellow-400 text-black text-lg md:text-2xl py-2 px-4 md:py-3 md:px-6 rounded hover:bg-yellow-300">INICIAR JUEGO</button>
        </div>

        <div id="game-over-screen" class="screen-overlay" style="display: none;">
            <h2 class="text-3xl md:text-5xl text-red-600 mb-8">FIN DEL JUEGO</h2>
            <p class="text-lg md:text-2xl mb-4">PUNTUACIÓN FINAL: <span id="final-score" class="text-yellow-400">0</span></p>
            <button id="restart-button" class="bg-yellow-400 text-black text-lg md:text-2xl py-2 px-4 md:py-3 md:px-6 rounded hover:bg-yellow-300">REINICIAR</button>
        </div>

        <!-- * HTML RESTAURADO: Controles táctiles --><div id="touch-controls" class="w-full">
            <!-- Controles de Movimiento (Izquierda) --><div class="flex items-center">
                <button id="touch-left" class="touch-btn">◀</button>
                <button id="touch-crouch" class="touch-btn">▼</button>
                <button id="touch-right" class="touch-btn">▶</button>
            </div>
            <!-- Controles de Acción (Derecha) --><div class="flex items-center">
                <!-- * NUEVO: Botón Táctil de Granada -->
                <button id="touch-grenade" class="touch-btn text-blue-400" style="opacity: 0.4;">G</button>
                <button id="touch-reload" class="touch-btn">R</button>
                <button id="touch-shoot" class="touch-btn text-red-500 font-bold">¡!</button>
                <button id="touch-jump" class="touch-btn">▲</button>
            </div>
        </div>
        <!-- FIN Controles táctiles --></div> <!-- Fin de game-container --><!-- * NUEVO: Elemento de Audio para la música de fondo --><audio id="bg-music" src="https://archive.org/download/tvtunes_30300/He-Man%20-%20Mistery.mp3" loop crossorigin="anonymous"></audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');

            // --- Elementos de la UI ---
            const scoreEl = document.getElementById('score');
            const ammoEl = document.getElementById('ammo');
            const reloadMessageEl = document.getElementById('reload-message');
            const startScreenEl = document.getElementById('start-screen');
            const gameOverScreenEl = document.getElementById('game-over-screen');
            const startButton = document.getElementById('start-button');
            const restartButton = document.getElementById('restart-button');
            const finalScoreEl = document.getElementById('final-score');
            
            // --- * NUEVO: Elementos de Granada ---
            const grenadesEl = document.getElementById('grenades');
            const buyGrenadeButton = document.getElementById('buy-grenade');
            const touchGrenade = document.getElementById('touch-grenade');

            const bgMusic = document.getElementById('bg-music');

            // --- Botones Táctiles ---
            const touchLeft = document.getElementById('touch-left');
            const touchRight = document.getElementById('touch-right');
            const touchCrouch = document.getElementById('touch-crouch');
            const touchJump = document.getElementById('touch-jump');
            const touchShoot = document.getElementById('touch-shoot');
            const touchReload = document.getElementById('touch-reload');
            // touchGrenade ya definido arriba

            // --- Configuración del Juego ---
            const FLOOR_Y = canvas.height - 5; 
            const PLAYER_X_INITIAL = 100;
            const PLAYER_HEIGHT_STANDING = 80;
            const PLAYER_HEIGHT_CROUCHING = 40;
            const PLAYER_WIDTH = 25;
            const BOX_SIZE = 60;
            const BARRICADE_OFFSET_FROM_PLAYER = 150;
            let BARRICADE_X;
            const PLAYER_SPEED = 3;
            const GRAVITY = 0.5;
            const JUMP_STRENGTH = -12;
            const GRENADE_COST = 2000; // * NUEVO

            // --- Variables de Estado ---
            let player;
            let barricade;
            let zombies;
            let particles;
            let activeShots;
            let ammo;
            let score;
            let isReloading;
            let reloadTimer;
            let keys = {};
            let gameOver;
            let gameLoopId;
            let zombieSpawnTimer;
            let zombieSpawnInterval;

            // * NUEVO: Variables de Granada
            let grenades;
            let activeGrenade = null;
            let explosions = [];

            // --- Input Handlers (Teclado) ---
            document.addEventListener('keydown', (e) => { keys[e.key] = true; });
            document.addEventListener('keyup', (e) => { keys[e.key] = false; });
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', startGame);
            buyGrenadeButton.addEventListener('click', buyGrenade); // * NUEVO

            // --- Input Handlers (Táctil) ---
            
            function setupHoldButton(element, keyName) {
                element.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys[keyName] = true;
                }, { passive: false });
                
                element.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys[keyName] = false;
                }, { passive: false });
                
                element.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    keys[keyName] = false;
                }, { passive: false });
            }

            function setupTapButton(element, keyName) {
                element.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys[keyName] = true;
                }, { passive: false });

                element.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    // La lógica de 'handleInput' ya se encarga de ponerlo en 'false'
                }, { passive: false });
            }

            // Asignar eventos a los botones
            setupHoldButton(touchLeft, 'a');
            setupHoldButton(touchRight, 'd');
            setupHoldButton(touchCrouch, 's');
            
            setupTapButton(touchJump, 'Control');
            setupTapButton(touchShoot, ' ');
            setupTapButton(touchReload, 'r');
            setupTapButton(touchGrenade, 'g'); // * NUEVO

            // --- Funciones Principales del Juego ---

            function init() {
                BARRICADE_X = PLAYER_X_INITIAL + BARRICADE_OFFSET_FROM_PLAYER;
                player = {
                    x: PLAYER_X_INITIAL,
                    y: FLOOR_Y - PLAYER_HEIGHT_STANDING,
                    width: PLAYER_WIDTH,
                    height: PLAYER_HEIGHT_STANDING,
                    state: 'standing',
                    vy: 0,
                    isOnGround: true
                };
                barricade = [
                    { x: BARRICADE_X, y: FLOOR_Y - BOX_SIZE, width: BOX_SIZE, height: BOX_SIZE, hp: 100 },
                    { x: BARRICADE_X, y: FLOOR_Y - (BOX_SIZE * 2), width: BOX_SIZE, height: BOX_SIZE, hp: 100 },
                    { x: BARRICADE_X + BOX_SIZE, y: FLOOR_Y - BOX_SIZE, width: BOX_SIZE, height: BOX_SIZE, hp: 100 },
                ];
                zombies = [];
                particles = [];
                activeShots = [];
                ammo = 8;
                score = 0;
                isReloading = false;
                gameOver = false;
                zombieSpawnInterval = 3000; 
                zombieSpawnTimer = zombieSpawnInterval;

                // * NUEVO: Inicializar granadas
                grenades = 0;
                grenadesEl.textContent = grenades;
                activeGrenade = null;
                explosions = [];

                scoreEl.textContent = score;
                ammoEl.textContent = ammo;
                reloadMessageEl.style.display = 'none';
                gameOverScreenEl.style.display = 'none';
                startScreenEl.style.display = 'none';
                
                updateBuyButton(); // * NUEVO
            }

            function startGame() {
                init();
                
                bgMusic.currentTime = 0;
                bgMusic.volume = 0.4;
                bgMusic.play().catch(e => console.warn("La reproducción automática de audio fue bloqueada por el navegador.", e));

                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                }
                gameLoop();
            }

            function endGame() {
                gameOver = true;
                bgMusic.pause();
                cancelAnimationFrame(gameLoopId);
                clearTimeout(reloadTimer);
                finalScoreEl.textContent = score;
                gameOverScreenEl.style.display = 'flex';
            }

            // --- * NUEVO: Lógica de Granadas ---

            function buyGrenade() {
                if (score >= GRENADE_COST) {
                    score -= GRENADE_COST;
                    grenades++;
                    scoreEl.textContent = score;
                    grenadesEl.textContent = grenades;
                    updateBuyButton();
                }
            }

            function updateBuyButton() {
                buyGrenadeButton.disabled = score < GRENADE_COST;
                touchGrenade.style.opacity = grenades > 0 ? '1' : '0.4';
            }
            
            function launchGrenade() {
                if (grenades <= 0 || activeGrenade || isReloading || player.state === 'crouching') return;
                
                grenades--;
                grenadesEl.textContent = grenades;
                updateBuyButton();

                activeGrenade = {
                    x: player.x + player.width / 2,
                    y: player.y + player.height / 3,
                    vx: 8, // Velocidad horizontal
                    vy: -14, // Velocidad vertical (hacia arriba)
                    radius: 6,
                    rotation: 0
                };
            }

            function updateActiveGrenade() {
                if (!activeGrenade) return;
                
                activeGrenade.vy += GRAVITY; // Aplicar gravedad
                activeGrenade.x += activeGrenade.vx;
                activeGrenade.y += activeGrenade.vy;
                activeGrenade.rotation += 0.1;

                // Detonar si toca el suelo o sale de la pantalla
                if (activeGrenade.y + activeGrenade.radius >= FLOOR_Y || activeGrenade.x > canvas.width) {
                    triggerExplosion(activeGrenade.x, activeGrenade.y > FLOOR_Y ? FLOOR_Y - 30 : activeGrenade.y);
                    activeGrenade = null;
                }
            }

            function triggerExplosion(x, y) {
                // Añadir una animación de explosión
                explosions.push({ x: x, y: y, radius: 0, maxRadius: 300, lifespan: 30, maxLifespan: 30 });

                // Eliminar todos los zombies
                for (let i = zombies.length - 1; i >= 0; i--) {
                    const z = zombies[i];
                    // Crear partículas para cada componente del zombie
                    for (const comp of z.components) {
                        if (comp.hp > 0) {
                            createParticles(z.x + comp.x, z.y + comp.y, comp.width, comp.height, comp.color);
                        }
                    }
                    score += 50; // Dar puntos por la baja con granada
                    zombies.splice(i, 1);
                }
                scoreEl.textContent = score;
                updateBuyButton(); // Actualizar el botón por si los puntos cambiaron
            }

            function updateExplosions() {
                for (let i = explosions.length - 1; i >= 0; i--) {
                    const exp = explosions[i];
                    exp.radius += exp.maxRadius / exp.maxLifespan; // Crecer
                    exp.lifespan--;
                    if (exp.lifespan <= 0) {
                        explosions.splice(i, 1);
                    }
                }
            }

            // --- Lógica de Actualización (Update) ---

            function handleInput() {
                if (gameOver) return;

                // --- Agacharse ---
                if ((keys['s'] || keys['ArrowDown']) && player.isOnGround) {
                    player.state = 'crouching';
                    player.y = FLOOR_Y - PLAYER_HEIGHT_CROUCHING;
                    player.height = PLAYER_HEIGHT_CROUCHING;
                    if (isReloading) {
                        clearTimeout(reloadTimer);
                        isReloading = false;
                        reloadMessageEl.style.display = 'none';
                    }
                } else if (player.state === 'crouching' && !(keys['s'] || keys['ArrowDown'])) {
                    player.state = 'standing';
                    player.height = PLAYER_HEIGHT_STANDING;
                    player.y = FLOOR_Y - PLAYER_HEIGHT_STANDING; 
                }

                if (player.state === 'crouching') return;

                // --- Movimiento Horizontal ---
                if (keys['a'] || keys['ArrowLeft']) {
                    player.x -= PLAYER_SPEED;
                    player.x = Math.max(0, player.x);
                }
                if (keys['d'] || keys['ArrowRight']) {
                    player.x += PLAYER_SPEED;
                    player.x = Math.min(BARRICADE_X + BOX_SIZE - player.width, player.x);
                }
                
                // --- Salto ---
                if (keys['Control'] && player.isOnGround) {
                    player.vy = JUMP_STRENGTH;
                    player.isOnGround = false;
                    player.state = 'standing'; 
                    player.height = PLAYER_HEIGHT_STANDING;
                    keys['Control'] = false;
                }

                if (keys[' ']) {
                    shoot();
                    keys[' '] = false;
                }

                if (keys['r']) {
                    reload();
                    keys['r'] = false;
                }
                
                // * NUEVO: Input de Granada
                if (keys['g']) {
                    launchGrenade();
                    keys['g'] = false;
                }
            }
            
            function shoot() {
                if (isReloading || player.state === 'crouching' || ammo <= 0) {
                    return;
                }

                ammo--;
                ammoEl.textContent = ammo;
                
                const shotOriginX = player.x + PLAYER_WIDTH;
                const shotOriginY = player.y + PLAYER_HEIGHT_STANDING / 2;
                const shotWidth = 400; 
                const shotHeight = 80; 

                activeShots.push({
                    x: shotOriginX,
                    y: shotOriginY - shotHeight / 2,
                    width: shotWidth,
                    height: shotHeight,
                    lifespan: 10,
                    maxLifespan: 10
                });

                for (let i = zombies.length - 1; i >= 0; i--) {
                    const z = zombies[i];
                    if (z.x > shotOriginX + shotWidth) continue; 

                    let hit = false;
                    const componentsToHit = z.type === 'crawler' ? z.components : z.components; // Ambos tienen componentes

                    for (const comp of componentsToHit) {
                        if (comp.hp <= 0) continue; 

                        const compX = z.x + comp.x;
                        const compY = z.y + comp.y;

                        if (compX < shotOriginX + shotWidth &&
                            compX + comp.width > shotOriginX &&
                            compY < shotOriginY + shotHeight / 2 && 
                            compY + comp.height > shotOriginY - shotHeight / 2)
                        {
                            comp.hp -= 35; 
                            hit = true;
                            if (comp.hp <= 0) {
                                createParticles(compX, compY, comp.width, comp.height, comp.color);
                                
                                if (z.type === 'normal') {
                                    if (comp.name === 'leg') {
                                        z.speed *= 0.5; 
                                    }
                                    if (comp.name === 'head' || comp.name === 'torso' || comp.name === 'arm') {
                                        z.isDead = true; 
                                    }
                                } else if (z.type === 'crawler') {
                                     if (comp.name === 'head' || comp.name === 'body') {
                                        z.isDead = true;
                                     }
                                }
                                score += 10;
                                updateBuyButton(); // * NUEVO: Actualizar por si se llegó a 2000
                            }
                        }
                    }
                    if (hit && z.isDead) {
                        zombies.splice(i, 1);
                        score += 50; 
                        scoreEl.textContent = score;
                        updateBuyButton(); // * NUEVO: Actualizar por si se llegó a 2000
                    }
                }
            }

            function reload() {
                if (isReloading || ammo === 8 || player.state === 'crouching') {
                    return;
                }
                isReloading = true;
                reloadMessageEl.style.display = 'block';
                reloadTimer = setTimeout(() => {
                    ammo = 8;
                    ammoEl.textContent = ammo;
                    isReloading = false;
                    reloadMessageEl.style.display = 'none';
                }, 2000); 
            }

            function createZombie() {
                const zombieType = Math.random() < 0.85 ? 'normal' : 'crawler'; 

                let zombieConfig;
                if (zombieType === 'normal') {
                    zombieConfig = {
                        height: 80, width: 30, yOffset: 0, speedMultiplier: 0.5,
                        components: [
                            { name: 'head', x: 5, y: 0, width: 20, height: 20, hp: 25, color: '#C0EBC0' },
                            { name: 'torso', x: 0, y: 20, width: 30, height: 30, hp: 50, color: '#508D50' },
                            { name: 'leg', x: 4, y: 50, width: 10, height: 30, hp: 30, color: '#405D40' },
                            { name: 'leg', x: 16, y: 50, width: 10, height: 30, hp: 30, color: '#405D40' },
                            { name: 'arm', x: -6, y: 22, width: 6, height: 25, hp: 20, color: '#508D50' },
                            { name: 'arm', x: 30, y: 22, width: 6, height: 25, hp: 20, color: '#508D50' }
                        ]
                    };
                } else { // crawler
                    zombieConfig = {
                        height: 25, width: 50, yOffset: 5, // Ajustado yOffset para que esté sobre el suelo
                        speedMultiplier: 0.8,
                        components: [
                            { name: 'body', x: 0, y: 0, width: 50, height: 25, hp: 70, color: '#800080' },
                            { name: 'head', x: 15, y: -15, width: 20, height: 15, hp: 30, color: '#B060B0' }
                        ]
                    };
                }

                const y = FLOOR_Y - zombieConfig.height; // Ajustado para que yOffset no lo hunda
                const x = canvas.width + Math.random() * 100;

                zombies.push({
                    x: x, y: y, width: zombieConfig.width, height: zombieConfig.height,
                    speed: zombieConfig.speedMultiplier + Math.random() * 0.5 + (score / 7000), 
                    isDead: false, isAttacking: false, type: zombieType,
                    components: zombieConfig.components
                });
            }
            
            function updatePlayer(deltaTime) {
                if (player.state === 'crouching') {
                    player.vy = 0;
                    player.isOnGround = true;
                    return; 
                }
                player.height = PLAYER_HEIGHT_STANDING;
                player.vy += GRAVITY;
                player.y += player.vy;
                player.isOnGround = false; 

                if (player.y + player.height >= FLOOR_Y) {
                    player.y = FLOOR_Y - player.height;
                    player.vy = 0;
                    player.isOnGround = true;
                }

                let onBox = false;
                for (const box of barricade) {
                    if (box.hp <= 0) continue;
                    const hOverlap = player.x < box.x + box.width && player.x + player.width > box.x;
                    const prevBottom = (player.y - player.vy) + player.height;
                    const currBottom = player.y + player.height;

                    if (hOverlap && player.vy > 0 && prevBottom <= box.y && currBottom >= box.y) {
                        player.y = box.y - player.height; 
                        player.vy = 0;
                        player.isOnGround = true;
                        onBox = true;
                        break; 
                    }
                }
                if (!onBox && player.isOnGround && player.y + player.height < FLOOR_Y) {
                    player.isOnGround = false; 
                }
            }


            function updateZombies(deltaTime) {
                zombieSpawnTimer -= deltaTime;
                if (zombieSpawnTimer <= 0) {
                    createZombie();
                    zombieSpawnTimer = zombieSpawnInterval;
                    if (zombieSpawnInterval > 500) {
                        zombieSpawnInterval -= 20;
                    }
                }

                for (let i = zombies.length - 1; i >= 0; i--) {
                    const z = zombies[i];
                    z.isAttacking = false;

                    if (z.type === 'normal') {
                        let blocked = false;
                        for (const box of barricade) {
                            if (box.hp > 0 && z.x < box.x + box.width && z.x + z.width > box.x) {
                                if(z.y + z.height > box.y && z.y < box.y + box.height) {
                                    blocked = true;
                                    if (!(player.isOnGround && player.y < box.y && player.x + player.width > box.x && player.x < box.x + box.width)) {
                                        z.isAttacking = true;
                                        box.hp -= 0.1; 
                                    }
                                }
                            }
                        }
                        if (!blocked) {
                            const hOverlap = z.x < player.x + player.width && z.x + z.width > player.x;
                            const vOverlap = z.y < player.y + player.height && z.y + z.height > player.y;
                            if (hOverlap && vOverlap) { 
                                endGame();
                                return;
                            }
                        }
                        if (!z.isAttacking) {
                            z.x -= z.speed;
                        }
                    } else if (z.type === 'crawler') {
                        z.x -= z.speed;
                        const hOverlap = z.x < player.x + player.width && z.x + z.width > player.x;
                        const vOverlap = z.y < player.y + player.height && z.y + z.height > player.y;
                        if (hOverlap && vOverlap) { 
                            endGame();
                            return;
                        }
                    }
                }
            }

            function createParticles(x, y, w, h, baseColor = '#DCE6FF') {
                for (let i = 0; i < 20; i++) {
                    const finalColor = baseColor.startsWith('rgba') ? baseColor : `rgba(${parseInt(baseColor.slice(1,3), 16)}, ${parseInt(baseColor.slice(3,5), 16)}, ${parseInt(baseColor.slice(5,7), 16)}, ${Math.random() * 0.5 + 0.4})`;
                    particles.push({
                        x: x + Math.random() * w, y: y + Math.random() * h,
                        vx: (Math.random() - 0.4) * 4, vy: (Math.random() - 0.5) * 5, 
                        size: Math.random() * 4 + 1, color: finalColor, lifespan: 120 
                    });
                }
            }

            function updateParticles() {
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1; 
                    p.lifespan--;
                    if (p.lifespan <= 0) {
                        particles.splice(i, 1);
                    }
                }
            }

            function updateActiveShots() {
                for (let i = activeShots.length - 1; i >= 0; i--) {
                    const shot = activeShots[i];
                    shot.lifespan--;
                    if (shot.lifespan <= 0) {
                        activeShots.splice(i, 1);
                    }
                }
            }

            // --- Lógica de Dibujo (Draw) ---

            function drawPlayer() {
                ctx.save();
                if (player.state === 'standing') {
                    ctx.fillStyle = '#303080'; 
                    ctx.fillRect(player.x, player.y + 45, 10, 35); 
                    ctx.fillRect(player.x + 15, player.y + 45, 10, 35); 
                    ctx.fillStyle = '#5050FF'; 
                    ctx.fillRect(player.x - 2, player.y + 15, 29, 30);
                    ctx.fillStyle = '#FFC0A0';
                    ctx.fillRect(player.x + 7, player.y, 11, 15);
                    
                    ctx.fillStyle = '#402010'; 
                    ctx.fillRect(player.x + 10, player.y + 25, 25, 8); 
                    ctx.fillStyle = '#555'; 
                    ctx.fillRect(player.x + 35, player.y + 27, 20, 4); 
                } else { // 'crouching'
                    ctx.fillStyle = '#303080'; 
                    ctx.fillRect(player.x, player.y + 10, 25, 30);
                    ctx.fillStyle = '#FFC0A0';
                    ctx.fillRect(player.x + 7, player.y, 11, 10);
                    
                    ctx.fillStyle = '#402010';
                    ctx.fillRect(player.x + 10, player.y + 15, 25, 8);
                    ctx.fillStyle = '#555';
                    ctx.fillRect(player.x + 35, player.y + 17, 20, 4);
                }
                ctx.restore();
            }
            
            function drawBarricade() {
                for (const box of barricade) {
                    if (box.hp > 0) {
                        const healthPercent = box.hp / 100;
                        const g = Math.floor(160 * healthPercent);
                        const b = Math.floor(100 * healthPercent);
                        ctx.fillStyle = `rgb(180, ${g}, ${b})`;
                        ctx.fillRect(box.x, box.y, box.width, box.height);
                        ctx.strokeStyle = '#000';
                        ctx.strokeRect(box.x, box.y, box.width, box.height);
                    }
                }
            }

            function drawZombies() {
                for (const z of zombies) {
                    for (const comp of z.components) {
                        if (comp.hp > 0) {
                            ctx.fillStyle = comp.color;
                            ctx.fillRect(z.x + comp.x, z.y + comp.y, comp.width, comp.height);
                        }
                    }
                }
            }
            
            function drawParticles() {
                for (const p of particles) {
                    ctx.fillStyle = p.color; 
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                }
            }
            
            function drawSingleShot(shot) {
                const opacity = shot.lifespan / shot.maxLifespan; 
                ctx.fillStyle = `rgba(255, 220, 100, ${opacity * 0.9})`; 
                ctx.beginPath();
                ctx.moveTo(shot.x, shot.y + shot.height/2);
                ctx.lineTo(shot.x + shot.width, shot.y); 
                ctx.lineTo(shot.x + shot.width, shot.y + shot.height); 
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.9})`;
                ctx.beginPath();
                ctx.moveTo(shot.x, shot.y + shot.height/2);
                ctx.lineTo(shot.x + shot.width * 0.7, shot.y + shot.height * 0.3); 
                ctx.lineTo(shot.x + shot.width * 0.7, shot.y + shot.height * 0.7); 
                ctx.closePath();
                ctx.fill();
            }

            // --- * NUEVO: Funciones de Dibujo de Granada/Explosión ---
            function drawActiveGrenade() {
                if (!activeGrenade) return;
                ctx.save();
                ctx.translate(activeGrenade.x, activeGrenade.y);
                ctx.rotate(activeGrenade.rotation);
                ctx.fillStyle = '#228B22'; // Dark green
                ctx.fillRect(-activeGrenade.radius, -activeGrenade.radius, activeGrenade.radius * 2, activeGrenade.radius * 2);
                ctx.fillStyle = '#FFD700'; // Gold top
                ctx.fillRect(-activeGrenade.radius / 2, -activeGrenade.radius - 3, activeGrenade.radius, 3);
                ctx.restore();
            }

            function drawExplosions() {
                for (const exp of explosions) {
                    const opacity = exp.lifespan / exp.maxLifespan;
                    ctx.beginPath();
                    ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 165, 0, ${opacity * 0.7})`; // Orange
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(exp.x, exp.y, exp.radius * 0.6, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 0, ${opacity * 0.8})`; // Yellow
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(exp.x, exp.y, exp.radius * 0.3, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`; // White
                    ctx.fill();
                }
            }


            // --- Game Loop ---
            let lastTime = 0;
            function gameLoop(timestamp = 0) {
                if (gameOver) return;

                const deltaTime = timestamp - lastTime;
                lastTime = timestamp;

                // Actualizar estado
                handleInput();
                updatePlayer(deltaTime);
                updateZombies(deltaTime);
                updateParticles();
                updateActiveShots();
                updateActiveGrenade(); // * NUEVO
                updateExplosions(); // * NUEVO

                // Dibujar
                ctx.clearRect(0, 0, canvas.width, canvas.height); 
                drawBarricade();
                drawPlayer();
                drawZombies();
                drawParticles();
                
                for (const shot of activeShots) {
                    drawSingleShot(shot);
                }
                
                drawActiveGrenade(); // * NUEVO
                drawExplosions(); // * NUEVO

                gameLoopId = requestAnimationFrame(gameLoop);
            }
        });
    </script>
</body>
</html>
